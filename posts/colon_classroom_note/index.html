<!doctype html>
<html lang="en-us">
  <head>
    <title>Colon_classroom_note // My New Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://wangjieshuai.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Colon_classroom_note"/>
<meta name="twitter:description" content="chapter01 低级语言 重实现, 重过程
高级语言 重描述, 重目标
框架和库 框架  协同工作的类或函数 复杂应用中宏观管理上选取框架以控制整体的结构和流程 使设计者在特定领域整体设计上不必重新造轮子 约束开发者 控制反转(ioc), 框架调用开发者代码  库  应用在微观上利用库来解决具体的细节问题 是开发者摆脱底层代码, 专注于特定问题和业务逻辑 给开发者自由 开发者代码调用库函数  设计模式和架构 设计模式是软件的战术思想, 架构是软件的战略思想, 他们不是软件产品,而是软件思想.
图灵完备 一个能计算出每个图灵可计算函数 Turing-computable function的计算系统成为图灵完备的
chapter02 命令范式 行动导向, 算法显性, 目标隐性
世界观 程序是由若干行动指令组成的有序列表
方法论 用变量存储数据, 用语句执行指令
过程式编程 指引入了过程procedure, 函数function 或子程序subroutine/subprogram的命令式编程
声明范式 目标驱动, 目标显性, 算法隐性
函数式编程 逻辑式编程 迭代和递归 命令式语言 - 提倡迭代而不鼓励递归 更符合命令式思维, 递归开销大
声明式语言 - 提倡递归而不鼓励迭代 语法不允许迭代的循环变量, 且迭代着眼微观过程而递归着眼宏观规律
编程寻求一种机制, 将指定的输入转化为制定的输出.
对象范式 以数据为中心组织逻辑,将系统视为相互作用的对象集合,并利用继承于多态来增强可维护性, 可扩展性和可重用性."/>

    <meta property="og:title" content="Colon_classroom_note" />
<meta property="og:description" content="chapter01 低级语言 重实现, 重过程
高级语言 重描述, 重目标
框架和库 框架  协同工作的类或函数 复杂应用中宏观管理上选取框架以控制整体的结构和流程 使设计者在特定领域整体设计上不必重新造轮子 约束开发者 控制反转(ioc), 框架调用开发者代码  库  应用在微观上利用库来解决具体的细节问题 是开发者摆脱底层代码, 专注于特定问题和业务逻辑 给开发者自由 开发者代码调用库函数  设计模式和架构 设计模式是软件的战术思想, 架构是软件的战略思想, 他们不是软件产品,而是软件思想.
图灵完备 一个能计算出每个图灵可计算函数 Turing-computable function的计算系统成为图灵完备的
chapter02 命令范式 行动导向, 算法显性, 目标隐性
世界观 程序是由若干行动指令组成的有序列表
方法论 用变量存储数据, 用语句执行指令
过程式编程 指引入了过程procedure, 函数function 或子程序subroutine/subprogram的命令式编程
声明范式 目标驱动, 目标显性, 算法隐性
函数式编程 逻辑式编程 迭代和递归 命令式语言 - 提倡迭代而不鼓励递归 更符合命令式思维, 递归开销大
声明式语言 - 提倡递归而不鼓励迭代 语法不允许迭代的循环变量, 且迭代着眼微观过程而递归着眼宏观规律
编程寻求一种机制, 将指定的输入转化为制定的输出.
对象范式 以数据为中心组织逻辑,将系统视为相互作用的对象集合,并利用继承于多态来增强可维护性, 可扩展性和可重用性." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wangjieshuai.github.io/posts/colon_classroom_note/" />
<meta property="article:published_time" content="2019-09-09T00:08:06&#43;08:00"/>
<meta property="article:modified_time" content="2019-09-09T00:08:06&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://wangjieshuai.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>My New Hugo Site</h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Colon_classroom_note</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 9, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          7 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h3 id="chapter01">chapter01</h3>

<p>低级语言 重<strong>实现</strong>, 重<strong>过程</strong><br />
高级语言 重<strong>描述</strong>, 重<strong>目标</strong></p>

<h4 id="框架和库">框架和库</h4>

<h5 id="框架">框架</h5>

<ul>
<li>协同工作的类或函数</li>
<li>复杂应用中宏观管理上选取框架以控制整体的结构和流程</li>
<li>使设计者在特定领域整体设计上不必重新造轮子</li>
<li>约束开发者</li>
<li>控制反转(ioc), 框架调用开发者代码</li>
</ul>

<h5 id="库">库</h5>

<ul>
<li>应用在微观上利用库来解决具体的细节问题</li>
<li>是开发者摆脱底层代码, 专注于特定问题和业务逻辑</li>
<li>给开发者自由</li>
<li>开发者代码调用库函数</li>
</ul>

<h5 id="设计模式和架构">设计模式和架构</h5>

<p>设计模式是软件的战术思想, 架构是软件的战略思想, 他们不是软件产品,而是软件思想.</p>

<h5 id="图灵完备">图灵完备</h5>

<p>一个能计算出每个图灵可计算函数 Turing-computable function的计算系统成为图灵完备的</p>

<h3 id="chapter02">chapter02</h3>

<h4 id="命令范式">命令范式</h4>

<p>行动导向, 算法显性, 目标隐性</p>

<h5 id="世界观">世界观</h5>

<p>程序是由若干行动指令组成的有序列表</p>

<h5 id="方法论">方法论</h5>

<p>用变量存储数据, 用语句执行指令</p>

<h5 id="过程式编程">过程式编程</h5>

<p>指引入了过程procedure, 函数function 或子程序subroutine/subprogram的命令式编程</p>

<h4 id="声明范式">声明范式</h4>

<p>目标驱动, 目标显性, 算法隐性</p>

<h5 id="函数式编程">函数式编程</h5>

<h5 id="逻辑式编程">逻辑式编程</h5>

<h5 id="迭代和递归">迭代和递归</h5>

<p>命令式语言
- 提倡迭代而不鼓励递归
更符合命令式思维, 递归开销大</p>

<p>声明式语言
- 提倡递归而不鼓励迭代
语法不允许迭代的循环变量, 且迭代着眼微观过程而递归着眼宏观规律</p>

<p>编程寻求一种机制, 将指定的输入转化为制定的输出.</p>

<h4 id="对象范式">对象范式</h4>

<p>以数据为中心组织逻辑,将系统视为相互作用的对象集合,并利用继承于多态来增强可维护性, 可扩展性和可重用性.</p>

<p>oop大多是命令式编程, 不能脱离其他范式, 也绝非适用于一切应用.</p>

<p>可维护性, 可扩展性, 可重用性 是所有范式和语言的共同目标, 并非oop所独有.</p>

<p>与其说oop具有重用性, 不如说更具有易用性. 比如, 函数的重用性高于对象.</p>

<p>对象式编程以数据为中心,自顶向下,逐步求精<br />
过程式编程以过程为中心,自底向上,逐步合并</p>

<h4 id="并发范式-合作与竞争">并发范式-合作与竞争</h4>

<p>以进程为导向, 以任务为中心将系统模块化,以资源共享和竞争为主线</p>

<p>采用共享内存的并发模型中需要同步, 而采用消息传递的并发模型中并不需要.</p>

<h3 id="chapter03">chapter03</h3>

<h4 id="泛型范式">泛型范式</h4>

<p>将算法和数据结构分离, 并将后者尽可能的泛化, 最大限度的实现算法重用.</p>

<p>泛化是<strong>基于模板的参数多态</strong>,
而OOP是<strong>基于继承的子类型多态</strong></p>

<p>STL三要素: algorithm, container, iterator</p>

<p>泛型编程能打破静态类型语言的数据类型之间的壁垒, 在不牺牲效率并确保类型安全的情况下, 最大限度的提高算法的普适性.</p>

<p>泛型编程不仅能泛化算法中涉及的概念(数据类型), 还能泛化行为(函数, 方法, 运算)</p>

<p>泛型编程时算法导向的, 以算法为中心, 逐渐将其所设计的概念内涵模糊化, 外延扩大化, 将其所设计的运算抽象化, 一般化, 从而提高算法的重用性</p>

<h4 id="超级范式-元编程-lop">超级范式 元编程 LOP</h4>

<p>编写操纵程序的程序, 在元编程中, 运算和程序本身都是动态的</p>

<p>元程序将程序作为数据来对待, 有着其他程序所不具备的自觉性, 自适应性和智能性, 可以说是最高级的一种程序.</p>

<h4 id="切面范式aop-多角度看问题">切面范式AOP - 多角度看问题</h4>

<p>高内聚, 低耦合: 单一化, 正交化, 每个模块职责明确专一, 模块之间相互独立</p>

<p>SOC: separation of concerns 关注点分离</p>

<p>DRY: don&rsquo;t repeat yourself  尽量较少重复代码</p>

<p>抽象是前提, 分解是方式, 模块化是结果</p>

<p>OOP沿着继承树的纵向方向重用, AOP可以沿横向方向重用</p>

<h4 id="事件驱动">事件驱动</h4>

<p>事件驱动, 观察者模式, 回调函数, 框架, 控制反转</p>

<p>轮询polling-&gt;取决于自身观察判断-&gt;流程驱动式编程</p>

<p>托付式等通知-&gt;取决于外来的突发事件-&gt;事件驱动式编程</p>

<p>依赖反转原则: 高层模块不应依赖底层模块, 他们都应该依赖于抽象; 抽象不依赖于细节, 细节应该依赖于抽象</p>

<p>主题是控制与依赖, 目的是解耦, 方法是反转, 实现的关键是抽象接口</p>

<p><strong>控制反转-&gt;被动性</strong></p>

<p><strong>不可预测-&gt;异步性</strong></p>

<p>独立式异步的前提, 耗时是异步的理由</p>

<h3 id="chapter04">chapter04</h3>

<h4 id="函数范式">函数范式</h4>

<p>haskell
无副作用, 无显示内存管理, 便于并发和优化, 过于数学化和抽象</p>

<h4 id="逻辑范式-当算法失去了控制">逻辑范式&ndash;当算法失去了控制</h4>

<p>算法 = 逻辑 + 控制
模拟人类的逻辑思维, 更简洁\抽象\少副作用, 但巡行效率偏低, 可掌控性较差, 适合于基于规则(rule-based)而不是基于状态(state-based)的应用.</p>

<p>代码的长度不是衡量软件复杂度的唯一标准, 其中的逻辑结构越复杂越微妙, 受需求变化的影响就越大, 软件越难以控制和维护.</p>

<h4 id="汇总范式">汇总范式</h4>

<h5 id="编程范式-vs-设计模式">编程范式 vs 设计模式</h5>

<p>设计模式一般针对某一特定场景的问题, 而编程范式针对的是广泛的多的问题领域, 通常有一整套的思想和理论体系, 具有全局性\系统性\渗透性</p>

<p>同样的思想, 用在结构设计上, 称为架构模式; 在局部模块的细节实现上, 称为设计模式; 用在引导编程实践上, 则称为编程范式</p>

<p>设计模式是遵循设计原则的一些具体技巧, 以保证代码的可维护性, 扩展性和可重用性, 重在设计,对语言没有要求; 编程范式往往对语言有专门的要求, 语言本身就是围绕其所倡导的核心范式来设计的.</p>

<h4 id="情景范式">情景范式</h4>

<p>闭包(closure)-&gt;所谓包, 是指函数与其周围环境变量捆绑打包; 所谓闭, 指这些变量是封闭的, 只能为该函数所用.</p>

<p>特征:内部匿名函数(类)</p>

<h3 id="chapter05小结">chapter05小结</h3>

<p>迭代学习法: 在具体知识和抽象理论之间进行增量式的循环学习.</p>

<p>一个合格的程序员不应只局限于某一层的应用开发</p>

<h4 id="数据类型-规则和变通">数据类型-规则和变通</h4>

<p><strong>静态类型</strong>: 有罪推定, 疑罪从有<br />
<strong>动态类型</strong>: 无罪推定, 疑罪从无</p>

<p>尽可能守规矩, 必要时变通</p>

<p><strong>数据类型的要素</strong>: 允许取值的集合 允许参与的运算</p>

<p>一定程度上提高代码的安全性, <strong>用户自定义类型</strong>, 如struct和class, 赋予数据以逻辑内涵, 提高代码的抽象性</p>

<p>针对机器的<strong>物理意义</strong>: 进行底层的内存分配和逻辑运算<br />
针对人的<strong>逻辑意义</strong>: 表达高层的逻辑概念</p>

<p><strong>静态类型语言</strong>: 类型检查发生在运行之前<br />
<strong>动态类型语言</strong>: 类型检查发生在运行期间的语言</p>

<p>类型的动静以类型的绑定时间来区分, 类型的强弱以类型的约束强度来区分. 弱类型语言允许类型隐式转换&copy;, 而强类型语言不允许(Java).</p>

<h3 id="chapter06语言简评">chapter06语言简评</h3>

<h4 id="系统语言">系统语言</h4>

<h5 id="c">C++</h5>

<p><strong>RAII</strong>(resource acquisition is initialization):
资源的释放和对象的生命周期绑定</p>

<p>在栈上创建对象, 一旦超出其作用范围, 便自动释放内存</p>

<p>优化机器的时间而不是人的时间, 优化机器的记忆而不是人的记忆, 假设编译器是愚蠢的而人是聪明的, 赋予人更多的权力和责任.</p>

<p><strong>书籍推荐</strong></p>

<p>The C programing language  K&amp;R</p>

<p>初级:
C++ primer
Thinking in c++
中级:
The c++ programing language
Effective c++
高级:
The c++ in depth
The design and evolution of c++</p>

<h4 id="平台语言">平台语言</h4>

<p>java和c# 能独立于操作系统和硬件,是因为他们自带了运行环境平台.
1. 均编译称机器无关的字节码, 运行于虚拟机上
2. 禁用或限用指针, 支持自动垃圾回收机制</p>

<p>Java: 让一种语言在多种平台上运行
C#: 让多种语言在一种平台上运行</p>

<p>编程语言的发展是技术和商业合力推动的结果.</p>

<h4 id="前台语言">前台语言</h4>

<p>前台编程涉及面专, 后台编程涉及面广, 需要深厚的技术积累和设计思维, 底层编程涉及面深</p>

<h4 id="后台脚本-敏捷开发利器">后台脚本-敏捷开发利器</h4>

<p>python, perl, ruby, PHP</p>

<h3 id="chapter07-抽象与封装">chapter07 抽象与封装</h3>

<p>抽象:去粗取精, 化繁为简, 由表及里, 艺中求同. 做减法和除法</p>

<p>防御性编程: 先小人后君子
契约式编程: 先君子后小人</p>

<p>契约式设计中, 实现中包含设计, 模型驱动设计中, 设计中包含实现</p>

<p><strong>抽象思维能力</strong></p>

<p>抽象程度越高, 细节越少, 普适性越强</p>

<p>将复杂的现实世界映射到精确严格的虚拟世界, 完成多对一的对应, 抽象是必经之路</p>

<p>分析(OOA)-&gt;设计规范; 设计(OOD)-&gt;实现规范; 实现(OOP)-&gt;软件编码</p>

<p>分析: 以性质为导向抽象, 定性,  抽象程度高
设计: 采用数学模型导向抽象, 定量, 抽象程度低
实现: 采用参数抽象和规范抽象</p>

<h5 id="参数抽象-abstraction-of-parameterization">参数抽象 abstraction of parameterization</h5>

<h5 id="规范抽象-abstraction-of-specification">规范抽象 abstraction of specification</h5>

<p>契约式编程: assert</p>

<p>抽象程度越高, 越接近设计, 越远离实现, 相应的语言等级也越高; 稳定性越高, 普适性越强, 可重用性越高</p>

<p>过程抽象 procedural abstraction
数据抽象 data abstraction
迭代抽象 iteration abstraction
类型层级 type hierarchy
多态抽象 polymorphic abstraction</p>

<h4 id="数据抽象">数据抽象</h4>

<p>数据结构强调具体实现, 多从实现者和维护者的角度来考虑; 抽象数据类型 强调接口抽象, 多从设计者和使用者的角度考虑.</p>

<p>参数抽象使得数据接口普适化, 规范抽象使得数据接口契约化
例如queue可以由数组实现,也可以由链表实现</p>

<p>OOA以对象而非过程为中心, OOP以数据而非算法为中心, OOD以接口而非实现为中心</p>

<p>Java中用static声明函数表明此函数为内部函数</p>

<p><strong>抽象是OOP的核心和起源, 是封装,继承,多态的基础</strong></p>

<h4 id="封装隐藏">封装隐藏</h4>

<p>封装, 将数据和相关行为包装在一起以实现信息隐藏</p>

<p>信息隐藏是一种原则, 而封装是实现这种原则的一种方式</p>

<p>信息隐藏原则固然重要, 但是也不是金科玉律, 在一定条件下是允许开放的</p>

<p>关心对象的<strong>值</strong>还是<strong>同一性</strong></p>

<p>关心值的化, 不希望不同的对象因共享引用而导致值被修改, 所以进行值拷贝</p>

<p>关心同一性的化, 关心的是对象本身, 不需要也不应该进行值拷贝</p>

<ul>
<li>不要过分追求getter和setter的对称</li>
<li>函数命名不要暴露其实现方式</li>
</ul>

<p>访问控制 不仅是一种语法规则, 也是一种语义规范, 明确的将接口和实现分离开来</p>

<p>抽象和封装是OOP的关键所在</p>

<h3 id="chapter08-抽象接口">chapter08 抽象接口</h3>

<h4 id="软件应变">软件应变</h4>

<p>适应变化能力是衡量软件质量的重要标准</p>

<p>一方面, 抽象接口描述了一个对象最本质的特征, 另一方面, 具体实现可以随时变动, 隐藏他们保证变动不会波及客户代码</p>

<p>软件之软,体现在适应变化的能力上. 许多编程思想包括OOP都是以提高应变能力为主题, 抽象和封装便是典型代表.</p>

<ul>
<li>抽象: 将一个对象模型最本质因而不易发生变化的部分提炼出来</li>
<li>封装(信息隐藏): 将非本质, 易变化的部分隐藏起来</li>
</ul>

<p>将一个对象划分为阴阳两面, 从而提高软件的抗辩能力</p>

<p>由于c++需要头文件, 即使私有成员也必须在头文件中声明, 这意味着改动任何私有数据结构甚至私有方法, 所有包含该头文件的源文件虽然不必重写, 却须重新编译链接.   这个对大型程序来说是难以忍受的, 同时也说明设计和语言是息息相关的</p>

<p>C++中应该尽量使用前置声明, 减少包含头文件.</p>

<p>开闭原则: 对修改封闭, 对扩展开放.</p>

<h4 id="访问控制-代码的多级管理">访问控制&ndash; 代码的多级管理</h4>

<p>方式: 包, 域, 方法, 嵌套类,</p>

<p>选择修饰符: 尽可能选择限制性强的修饰符</p>

<h5 id="c-friend修饰符">C++ friend修饰符</h5>

<p>类的职责应该单一, 但如果一个类过于庞大, 应该按功能进行划分, 使其更容易维护, 为了方便访问不应该public的信息, 这时候就需要使用friend修饰符</p>

<p>friend是单向授权的, 可以看作是private的一种细化. 即类A声明类B为friend, 类B可以访问类A
的私有成员, 而类B却不能访问类A的私有成员.</p>

<p>访问控制实对静态代码的控制, 而不是动态对象的控制, 所以同一个类的不同对象可以互相访问其private成员
- 从抽象角度看, 访问控制划分了抽象的边界, 一方面从语义上明确了抽象的层次化: 越公开的成员越抽象,原理实现; 另一方面从语法上实现双向保护, 既保护实现代码不受客户代码入侵, 又保护客户代码不受实现代码变更的影响.
- 从软件应变角度讲, 访问控制划分了代码修改的边界.</p>

<p>访问控制使得类的接口层次化, 职责层次化, 服务层次化, 客户层次化</p>

<h4 id="接口服务-讲诚信守规矩">接口服务&ndash;讲诚信守规矩</h4>

<ul>
<li>可靠性</li>
<li>稳定性</li>
<li>纯粹性</li>
<li>完备性</li>
</ul>

<h3 id="chapter09-继承机制">chapter09 继承机制</h3>

<h4 id="继承关系-继承财富-继承责任">继承关系- 继承财富, 继承责任</h4>

<p>实现继承消费了可重用的旧代码, 接口继承 生产可重用的新代码. 接口继承不是为了代码重用, 而是为了代码被重用</p>

<p>宏观上是对象式, 微观上是过程式</p>

<p>非public继承和组合都是对实现的重用而非接口的重用, 无论从实现方式还是表现形式, 都比较类似</p>

<p>里式替换原则: 一个类可以被他的子类型完美替换. 里氏替换原则的本质是为了保证规范抽象.</p>

<p>继承形式的接口与实现分离, 父类定义了抽象的规范, 具体实现交由子类进行处理.</p>

<p>尽可能弥合语义和语法之间的缝隙, 压缩代码bug的生存空间</p>

<p><strong>与其说继承是一种实现的技巧, 不如说是一种规范的技巧</strong></p>

<p><strong>概念抽象只是手段, 规范抽象才是一句</strong>, 在实际编程中, 体现类型概念的是他的行为规范, 而不是他的命名引发的认知.</p>

<p><strong>类和类型</strong>: 类偏重语法, 强调实现方式, 类型强调语义, 强调行为方式. 类是实现, 类型是接口.</p>

<h5 id="两种分离类的接口和实现的方式">两种分离类的接口和实现的方式</h5>

<ol>
<li>从语义上通过数据抽象得到接口, 在语法上通过封装隐藏实现</li>
<li>从语义上通过多态抽象得到接口, 在语法上通过继承隐藏实现</li>
</ol>

<p>这两对&rdquo;接口/实现&rdquo; 构成了OOP的主体特征, 其中2的抽象层次更高, 编程应优先针对高层的抽象接口</p>

<h4 id="慎用继承">慎用继承</h4>

<ul>
<li>继承是一种静态显性的关系. 静态, 是指在变异期间建立的, 且无法在运行期间改变的; 显性, 是指关系是公开的, 如果通过源码来改变, 将影响客户代码. 这类强耦合关系降低了软件的应变能力, 应尽量避免.</li>
<li>合成(组合)是隐性的, 属于内部实现. 还可以是动态的, 在运行期间决定具体的数据类型</li>
</ul>

<h5 id="继承破坏封装">继承破坏封装</h5>

<ol>
<li>子类拥有父类protected域成员和方法的特权</li>
<li>部分实现方式和内部逻辑暴露给了子类</li>
<li>子类可以覆盖父类的多态方法</li>
</ol>

<p>子类和父类在代码上是隔离的, 多态机制又是隐性的
1. 子类应当坚持父类的外在行为, 不破坏父类的服务规范
2. 子类应当正视父类的内在逻辑, 不能忽视或破坏父类规范之内的逻辑关联, 不能假设或依赖规范之外的逻辑关联. 例如: 子类调用父类的方法, 父类方法又通过多态调用子类的方法</p>

<h5 id="提倡接口继承-慎用实现继承">提倡接口继承, 慎用实现继承</h5>

<p>继承最大的硬伤, 在于建立了类与类之间的强耦合关系, 使代码趋于僵硬, 脆弱和复杂. 这种关系是永固的, 一旦建立无法解除; 这种关系是纵深的, 不限于相邻的父类和子类, 而是贯穿整个类族; 这种关系还是双向的, 从上到下, 从下到上.</p>

<h5 id="继承使用的场景">继承使用的场景</h5>

<ol>
<li>需要访问protected成员</li>
<li>需要覆盖基础类方法, 且难以用合成来实现的</li>
<li>需要称为基础类的子类型</li>
</ol>

<h5 id="判断是否应当用继承时的问题">判断是否应当用继承时的问题:</h5>

<ol>
<li>采用合成是否会遇到无法解决的困难</li>
<li>基础类是否专为继承而设计</li>
</ol>

<p>在公有和多态产生矛盾时, 既是非虚接口模式大显身手之际</p>

<p>无论从设计还是性能上来讲, 实例方法默认为不可覆盖或许更合理.  使用默认或是处于无意, 不用默认才是出于蓄谋. 鉴于多态给继承带来的微妙影响, 最好避免无意的多态. 确保多态是有意为之的设计.</p>

<p>类中对内实现的接口和对外提供服务的几口 进行分离. 对外的部分公有而不多态, 对内的部分多态而不公有.</p>

<p>C++支持但不提倡多重继承, 这里指的多重继承是指多重实现继承, 而不是接口继承; 而多重合成则不然. 推荐使用合成(组合)</p>

<h5 id="使用继承的注意项">使用继承的注意项</h5>

<ol>
<li>继承的层次不宜过深</li>
<li>在构造函数中不宜直接或间接调用多态方法</li>
<li>在clone或者serialize时需特别谨慎</li>
<li>除语义外, 还有语法, 修改基类导致的二进制兼容性问题</li>
</ol>

<p>当祖先类不能为后代类提供独立于其实现细节的服务时, 前者的封装就被破坏, 其改动可能会牵连后者, 造成<strong>脆弱的基类</strong>的问题</p>

<p>类的实例方法一般有四种用途:
1. 为外界提供服务的公开接口
2. 为子类提供扩展点的内部挂钩
3. 为子类或包提供服务的内部接口
4. 为自身提供服务的私有接口</p>

<p>以上4点除了第二点外, 都应该时非多态接口</p>

<h3 id="chapter10-多态机制">chapter10 多态机制</h3>

<h4 id="多态类型-静中之动">多态类型-静中之动</h4>

<p>静态语言的多态的两种实现方式:
1. 泛型编程(GP)的参数多态(parametric polymorphism). 在编译期将变量和其实际类型所定义的行为挂钩, 属于早绑定或者静态绑定. 从应用形式上看, 是发散的, 让相同的实现代码应用于不同的场合. 从思维方式上看, 是泛型式编程风格, 着重的是算法的普适性.<br />
2. OOP的包含多态(inclusion polymorphism). 在运行时将变量和其实际类型所定义的行为挂钩, 属于晚绑定或者动态绑定. 从应用形式上看, 是收敛的, 让不同的代码实现应用于相同的场合. 从思维方式上看, 是对象式编程, 着重于接口和实现的分析.</p>

<p>在保证必要的类型安全的前提下, 突破变异期间过于严苛的类型限制.</p>

<ul>
<li>基于类继承的多态</li>
<li>基于接口继承的多态</li>
<li>基于模板的多态</li>
</ul>

<p>策略模式赋予用户自由选择算法的权力
模板方法模式重在稳定坚固的骨架, 策略模式重在灵活多变的手腕</p>

<h4 id="抽象类型-实中之虚">抽象类型-实中之虚</h4>

<p>具体类型是创建对象的模板, 抽象类型是创建类型的模块</p>

<p>具体类描述对象, 重在实现; 抽象类描述规范, 重在接口</p>

<p>抽象数据类型的核心是数据抽象, 指类型的接口不依赖于其实现, 而抽象类型的核心是多态抽象</p>

<h4 id="mix-in">mix-in</h4>

<ol>
<li>抽象性和依赖性: 本身没有独立存在的意义, 必须融入主体才能发挥作用</li>
<li>实用性和可用性: 不仅提供接口, 还提供部分实现</li>
<li>专一性和细粒度性: 提供的接口职责明确而单一</li>
<li>可选性和边缘性: 为主体类型提供非核心辅助功能</li>
</ol>

<p>有些对象不希望被复制, 比如代表网络连接, 数据库连接的资源对象. 对于这类对象, 在C++中需要将其copy constructor 和 assigment operator 私有化.
1. 每个类使用宏声明来实现
2. 继承一个nonCopy的父类, 该父类的copy constructor 和 assignment operator是私有的</p>

<p>如果子类继承了NoCopyAble类, 那除非子类显示定义了自己的copy constructor和 assign operator, 否则执行默认的copy constructor和assign operator都会调用父类的相应方法, 由于父类的这些的方法是私有的, 就是编译出错, 通过这种方式避免了 调用类的默认的拷贝构造函数和赋值运算符</p>

<pre><code>class NoCopyAble {

protected:
    NoCopyAble() {
        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;
    }

    ~NoCopyAble() {
        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;
    }
private:
    NoCopyAble(const NoCopyAble&amp;) {
        cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;
    }
    void operator=(NoCopyAble&amp;) {
        cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;
    }
};

</code></pre>

<p>抽象的意义: 父类退出决定, 让子类选择实现的方式. 推迟 道出了 抽象类型除了创建类型之外的另一功用, 提供动态节点.</p>

<h4 id="接口与抽象类的语义区别">接口与抽象类的语义区别</h4>

<p>接口是一套功能完备的集合, 相同的接口代表相同的功能, 多表示&rdquo;can-do&rdquo;关系, 一般是对象的边缘特征, 在本质不同的类型之间建立横向联系; 抽象类是一类对象本质属性的抽象, 相同的抽象基类代表相同的种类, 多表示&rdquo;is-a&rdquo;的关系, 一般是对象的核心特征, 在本质相同的类型之间建立纵向联系; <strong>接口看重规范重用和可置换性, 抽象类看重代码重用和可扩展性</strong></p>

<h3 id="chapter11-值和引用">chapter11 值和引用</h3>

<h4 id="语法类型-体用之分">语法类型-体用之分</h4>

<h5 id="内存分配机制">内存分配机制</h5>

<ol>
<li>静态分配
发生于编译期, 为全局变量, 静态变量, 常数变量安排空间</li>
<li>栈分配
发生于运行期, 在编译期就能确定待分配内存的空间大小和生命周期, 主要用与存放局部变量和自动变量. 弊端: 无法突破作用域</li>
<li>堆分配
发生于运行期, 在运行时才能确定分配内存的空间大小和生命周期, 用于存放new, malloc等动态分配的空间. 弊端: 内存碎片, 时间效率, 内存泄漏, 元数据开销?</li>
</ol>

<p><strong>Java的实例变量都存在堆中, 默认都是new出来的, 局部变量存在栈中; 而C++则不同.</strong></p>

<p><strong>Java按值传递对象引用</strong></p>

<h5 id="内存碎片">内存碎片</h5>

<ol>
<li>浪费空间</li>
<li>浪费读写时间. 因为不连续的空间违背了局部性原理, 会增加高速缓存错失的几率.</li>
</ol>

<p><strong>多态必须通过引用或者指针来实现.</strong></p>

<h4 id="语义类型-阴阳之道">语义类型&ndash;阴阳之道</h4>

<p>语法只是手段, 语义才是目的</p>

<p><strong>石蕊测试法</strong>: 在不影响程序正确性的前提下, 一个对象的复件能否替代原件? 如果可以,则对象的类型是值语义的, 否则是引用语义的.</p>

<p>值通过具体的数据来描述抽象的属性, 引用通过抽象的方式来指代具体的实体.</p>

<p>Java中用 &ldquo;==&rdquo; 比较String, 比较的是引用的对象, 而不是String的值; 应该使用equal</p>

<p>Java中的引用对象是值语义的, 它的值是不可变的. 让它变化只是指向了新的引用对象. 不可变性为引用类型贯彻值语义提供了变通的语法支持.</p>

<p>值的不可变性(时间无关性)让语法的引用类型具有了值语义, 不可复制性让语法的值类型具有了引用语义.</p>

<h3 id="chapter12设计原则">chapter12设计原则</h3>

<h4 id="间接原则">间接原则</h4>

<p>任何计算机问题都可以通过增加一个间接层来解决</p>

<p>一个适当的中间层, 在形式上表现为间接层, 在实体上表现为抽象层</p>

<ul>
<li>间接</li>
<li>分离</li>
<li>抽象</li>
<li>规范</li>
</ul>

<p>三层架构(表示层, 业务层, 数据层)中的三个层级是线性关系, 通常是最高层的架构设计; 而MVC架构是三角关系, 主要用于交互式系统, 常常嵌入到3层架构的表示层中.</p>

<h4 id="依赖原则-有求则苦吗无欲则刚">依赖原则-有求则苦吗无欲则刚</h4>

<p>少一分责任则多一分专注, 内聚度随之增加; 少一分权力则多一分自由, 耦合度随之降低.</p>

<p>控制反转和 依赖反转: 通过引入抽象来摆脱对外界不必要的依赖, 争取对外界必要的控制.</p>

<p>控制反转侧重保证组件的可重用性, 依赖反转侧重保证组件的可维护性</p>

<p>抽象与规范是根本, 间接和分离是手段, 依赖和控制是关键, 接口和服务是核心</p>

<p>从过程式演化为对象式的过程, 是一个权力去中心化的工程.</p>

<p><strong>依赖反转原则 Dependence Inversion Principal</strong>:高层模块不应依赖于底层模块, 他们都应该依赖于抽象; 高层模块依赖于抽象接口, 而低层模块继承接口并实现. 接口一方面作为一种抽象类型, 定义了一类对象所应遵循的行为规范; 另一方面, 作为间接层, 把两个耦合的类进行了分离.</p>

<h5 id="合成与继承">合成与继承</h5>

<p>合成比继承的优势是 它是隐性的, 动态的, 这使得在合成类和被合成类之间有插入抽象层的可能. 当抽象层利用了多态机制时, 这种合成也叫做多态合成.</p>

<h4 id="内聚原则">内聚原则</h4>

<p>局部化原则: 让代码的物理紧密度和逻辑紧密度保持一致</p>

<p>一个理想的类在其所在的抽象层次上, 既是最小的一个可重用单元, 也是一个最小的可维护单元.</p>

<p>耦合不可能被完全消除, 因为模块之间是通过耦合来完成协作的. 要避免的是非本质的, 不恰当的或过于紧致的耦合.</p>

<p>局部化原则: 尽量把密切相关的软件元素放在一起</p>

<p>配置文件的缺点: 配置信息与其所关联的对象分属不同的文件, 造成理解和维护上的不便.违背了局部化原则</p>

<p>模块的每一种职责既是一个关注的焦点, 也是一个潜在的变化点. 职责, 变化点和关注点是三位一体的.</p>

<p>单一职责原则Simple Responsibility Principle(SIP): 一个类应当只有一个变更的理由.
<strong>接口隔离原则 Interface Segregation Principle(ISP)</strong>:</p>

<h4 id="保变原则-protected-variation">保变原则 Protected variation</h4>

<p>找出预计的变化点和不稳定点, 分配其职责以便用稳定的接口来包装.</p>

<p>封装是类级别(数据抽象层)的PV,多态是接口级别(多态抽象层)的PV</p>

<p><strong>衡量一个软件的设计质量最重要标准的可维护性. 灵活性, 扩展性, 重用性 都是为了保证维护性.</strong></p>

<h5 id="grasp-通用职责分配原则-general-responsibility-assignment-software-principle">GRASP 通用职责分配原则 general responsibility assignment software principle</h5>

<ul>
<li>信息专家: 把职责分配给信息专家&ndash;拥有完整该职责所需信息的类</li>
<li>创建者: 把创建类A实例的职责分配给类B, 如果一下条件之一成立: B包含A, B聚合A, B记录A, B密切使用A, B拥有A的初始化数据</li>
<li>控制器: 把处理系统事件的职责分配给代表整体系统或者 事件发生的用例场景</li>
<li>低耦合</li>
<li>高内聚</li>
<li>多态: 当相关的备选方案或行为因类型改变, 利用多态机制把职责分配给行为变化的类</li>
<li>纯虚构: 将一组高内聚的职责集合分配给一个虚构的行为类(不代表问题领域的概念),以支持高内聚低耦合</li>
<li>间接: 把职责分配给一个中间对象以避免两个组件或者服务的直接耦合</li>
<li>保变: 找出预计的变化点和不稳定点, 分配其职责以便用稳定的接口来包装</li>
</ul>

<h5 id="solid-类级设计原则">SOLID 类级设计原则</h5>

<ul>
<li>单一职责原则 SRP Signal Responsilitity Principle 一个类应当只有一个变化的理由</li>
<li>开闭原则 OCP Open-Close Principle 软件实体应当对扩产开放, 对修改封闭</li>
<li>里式替换原则 LSP Liskov Subsititution Principal 子类型必须能够替代超类型</li>
<li>接口隔离原则 ISP Interface Segragtion Principal 不应强迫客户依赖他们不需要的方法</li>
<li>依赖反转原则 DIP Dependency Inversion Principal 抽象不应依赖与细节, 细节应该依赖抽象</li>
</ul>

<h5 id="包级设计原则">包级设计原则</h5>

<ul>
<li>发布重用等价原则 Release Reuse Equivalency Principal 重用的粒度应该是发布分粒度</li>
<li>共用闭包原则 Common Closure Principal 同在一个包中的类应对同类变化封闭</li>
<li>共同重用原则 Common Reuse Principal 同在一个包中的类应该被一起重用</li>
<li>无环依赖原则 Acyclic Dependence Principal 在包的依赖图中不允许有环存在</li>
<li>稳定依赖原则 Stable Dependence Principal 朝着稳定的方向依赖</li>
<li>稳定抽象原则 Stable Abstraction Principal 一个包的抽象度应该与其稳定度相当</li>
</ul>

<h3 id="设计模式">设计模式</h3>

<h4 id="创建模式">创建模式</h4>

<h5 id="构造器的弊端">构造器的弊端</h5>

<ol>
<li>名字必须和类名一致, 不同的构造函数 只能用参数分辨, 缺乏表现力</li>
<li>每次调用都伴随着新对象的创建</li>
<li>无法被继承, 无法多态</li>
</ol>

<p><strong>静态工厂模式</strong>: 定义一个创建对象的工厂类,  该类中包含所有创建对象所需要的静态接口. 需要知道创建对象的具体类型, 耦合性强</p>

<p><strong>模板方法模式</strong>: 定义一个算法骨架, 并把某些步骤留给子类去定义</p>

<p><strong>工厂方法模式</strong>: 在创建对象的工厂抽象类中, 定义一套创建对象的虚方法, 具体的实现类中重载这些方法来创建实际所需要的类型</p>

<p><strong>抽象工厂模式</strong>: 将创建对象的工厂类型抽象化, 根据创建类型的不同 实现不同的子类工厂, 具体创建对象的类 使用 依赖注射 传入不同的工厂对象</p>

<p>工厂方法模式一般只针对一类产品, 产品增加时构建新类型的工厂; 而抽象工厂模式, 通常每个工厂生产一类型的多种产品</p>

<p><strong>依赖注射</strong>: 当某个类型不愿自己选择或管理依赖的对象时, 可以要求客户通过构造函数或者setter方法等途径来注入.</p>

<p><strong>建造者模式</strong>: 通过依赖注射一个builder, 使用builder来创建所有的component 并合成, 构建所需的对象</p>

<p><strong>原型模式</strong>: 通过clone自己来创建新的对象, 原型对象只供克隆,不能使用</p>

<h4 id="结构模式">结构模式</h4>

<p>关注于 如何把类和对象组成更大的结构, 实质上 就是 一个利用继承层级的类机构和聚合层级的对象结构 来构建更高层级抽象的过程.</p>

<p><strong>抽象是寻求某种一致性的过程,  反过来遵循一致性也有助于抽象的形成</strong></p>

<p>在oop中的某一区, 通常与某个包(C++中的namespace, Java中的package)相对应.</p>

<p>设计的过程就是对系统分解的过程</p>

<p>强类型的一大作用就是在一定程度上避免了不同抽象层次的调用</p>

<p>在OOP中, 类级别的模块最常用 的层级便是 类型层级和聚合层级</p>

<p><strong>桥接模式</strong>: 是接口和实现在逻辑和物理上分离, 使得一个类可以有多种实现, 并且可以动态切换.</p>

<p><strong>适配器模式</strong>: 接口转换器, 解决服务提供者和使用者直接接口不兼容的问题. 在继承的接口的实现中, 调用另一个对象的相关方法. 另一个对象于接口不兼容, 但是有重用价值.</p>

<p>桥接模式的重点是分解, 让本来紧密结合的接口和实现分离; 适配器模式的重点是结合, 让本来无关的两个类合作共事.</p>

<p><strong>装饰者模式</strong>: 为一个对象增加或者修改某些职责, 但这些职责只是辅助性或边缘性的职责, 不影响模块的内聚度. 有效分离类的核心功能和边缘功能正是装饰者的一大功用, 符合关注点分离原则.
边缘性往往体现在代码实现上, 通常装饰者再覆盖对象方法时, 仍保留其核心代码, 只在前后添加语句.</p>

<p><strong>代理模式</strong>: 目的是为了控制用户对某个对象的访问. 代理类与具体的实现类 继承同样的接口, 用户只能访问proxy类的方法, 但实际工作的类是实现类.(Android 的 Binder)</p>

<p>适配器模式改变对象的接口而保留其职责, 装饰者模式改变对象的职责而保留其接口, 代理模式也是保留接口改变职责. 不同的是, 装饰者模式通常是增强接口的服务, 而代理模式可能是限制接口的服务(保护代理), 或隐藏其实现细节.</p>

<p><strong>策略模式</strong>: 算法与对象本身解耦. 将一系列算法封装起来,并且是他们可以相互替换(变化).该模式使得算法可独立于使用他的客户程序(稳定)而变化(扩展, 子类化)</p>

<p><strong>外观模式</strong>: 将其他类(或者多个类)的接口 封装到 外观类中, 供外部对象使用, 建立一个 内部子系统和 外部客户之间的一个中间层. 通常会改变包装对象的接口</p>

<p><strong>复合模式</strong>: 类型层级和聚合层级类似于装饰者模式, 继承自相同的interface, 但composite和 其他子类的 的关联度比装饰者模式更强. 在composite的方法中调用所有其他子类的方法. 类似于GUI的布局管理, 设置window layout时递归设置了所有子window的layout.</p>

<p>复合模式通常是 一对多, 而装饰者模式通常是 一对一, 但都是开放式递归结构. 装饰者模式是为了动态增减功能, 同事避免子类膨胀, <strong>化继承为合成, 化静态为动态</strong>; 复合模式 是为了抽象理解和统一管理类型不同, 数量众多的数据结构, <strong>化不同为相同, 化多个为一个</strong></p>

<p><strong>享元模式</strong>: 抽象出一类对象内在的, 不因环境而异的状态, 封装后作为共享单元-flyweight. 用户需要承担更多的责任, 设置对象的上下文等等. 可以节省创建多个相同对象的资源.</p>

<h4 id="行为模式">行为模式</h4>

<p><strong>过滤器模式</strong>: 将复杂任务分解成一连串相对简单的步骤处理, 每个过滤器对 后面与之对接的过滤器一无所知, 不存在OOP中消息发送者和接收者之间的耦合.</p>

<p><strong>职责链模式</strong>: 每个handler相当于一个过滤器, 在处理完请求后传给职责链的下一环. 但消息发送者依然需要知道接收者的数据类型. 广泛应用于事件模型.</p>

<h5 id="写在配置文件中-不需要硬编码">写在配置文件中, 不需要硬编码</h5>

<h5 id="异常处理">异常处理</h5>

<ol>
<li>职责链意识: 有些任务需要分模块分批次分时间来完成</li>
<li>抽象层次意识: 不同抽象层次的对象处理不同层次的异常,  必要时通过包装提升异常的抽象层级交由上级处理.</li>
</ol>

<p>职责链模式关心的是职责的分解, 更侧重行为; 装饰者模式关心的是职责的结合, 更侧重结构.</p>

<p><strong>命令模式</strong>: OO化的异步回调. 将请求或者命令封装为一个对象, 命令对象包含了执行命令的全部信息&ndash;接收者, 方法, 参数.</p>

<p>回调函数的本质上是把代码当数据使用.</p>

<p><strong>观察者模式</strong>: 消息发送者可以把消息发送给多个消息接收者. 由于observer是以抽象接口方式注册的, 所以是松耦合. 好莱坞原则, 控制反转原则的应用, 适合底层模块对高层模块的反向控制.</p>

<h5 id="事件驱动模型">事件驱动模型</h5>

<h5 id="refactor模型">Refactor模型</h5>

<p><strong>中介者模式</strong>: 构造信息交换中心, 为众多平等的对象提供了交流的平台.</p>

<p><strong>状态模式</strong>: 利用间接的state对象来封装状态的变化. 把不同状态对应的行为包装到不同的模块中.</p>

<p><strong>备忘录模式</strong>: 在不破坏对象封装性的前提下, 捕获该对象的内部状态并保存在对象外部, 以后 实现对象的状态回溯. <strong>基本被序列化代替</strong>.</p>

<p>使用得当的化, friend修饰符 没有破坏封装, 反而是加强了封装.</p>

<p><strong>访问者模式</strong>: 克服语言中单分派机制的局限, 并能在不修改一个聚合体的前提下, 提供新的 作用于其所含元素之上的运算.</p>

<p>方法重载依据参数类型, 方法覆盖依据实例类型</p>

<p>静态分派: 在编译期决定, 如重载多态(overload polymorphism) 参数多态(parametric polymorphism)</p>

<p>动态分派: 在运行时决定, 如子类型多态(subtype polymorphism)</p>

<p><strong>迭代器模式</strong>: 迭代器作为容器和算法之间的中介, 既是二者的粘合剂, 也促使算法摆脱对数据接口的依赖, 从而具有普适性和重用性.</p>

<p><strong>解释器模式</strong>:</p>

<h4 id="各种设计模式解决的问题">各种设计模式解决的问题</h4>

<ul>
<li>工厂模式: 克服new运算符和构造器的局限</li>
<li>享元模式: 克服内存分配的局限</li>
<li>命令模式: 克服函数不是头等公民的局限</li>
<li>状态模式: 克服无法动态继承的局限</li>
<li>职责链, 观察者, 中介模式: 克服语法限制而造成的对象通信上的局限</li>
<li>访问者模式: 克服OOP语言单分派的局限</li>
</ul>

<h4 id="闭班小结">闭班小结</h4>

<p>编程-&gt;编程范式-&gt;可维护性-&gt;设计原则</p>

<p>设计原则高于设计模式, 设计模式源于设计原则</p>

<p>最核心的原则: <strong>抽象原则</strong>: 选择性的细节忽略:
- 降低程序的复杂性, 提高理解性
- 屏蔽了实现细节的变化对外界的影响,提高了代码的可维护性
- 缺少细节的代码普适性强, 适应面广, 提高了重用性, 灵活性, 稳定性
- 可逐步逐级的补充实现被忽略的细节, 提高扩展性和层次性</p>

<p>算法是程序的灵魂, 是软件的核心竞争力</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
